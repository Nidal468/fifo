// Generated by CoffeeScript 2.7.0
// vim: set expandtab tabstop=2 shiftwidth=2 softtabstop=2
var ApiClient, SESSION_STORAGE_KEY, SESSION_STORAGE_MECHANISM, e;
var log = function (...x) {
  try {
    return console.log(...x);
  } catch (error) { }
};
try {
  SESSION_STORAGE_MECHANISM = localStorage; // [sessionStorage, localStorage]
} catch (error) {
  e = error;
  SESSION_STORAGE_MECHANISM = new Map();
}

SESSION_STORAGE_KEY = 'sessionId';

ApiClient = class ApiClient {
  constructor(baseUrl = null, token1 = null) {
    this.query = this.query.bind(this);
    this.q = this.q.bind(this);
    this.baseUrl = baseUrl;
    this.token = token1;
    // external session id
    this.session = null;
    // jwt authentication
    this.token = null;
  }

  setToken(token) {
    return this.token = token;
  }

  async getSession(opt = {}) {
    var cacheHit, data, r;
    data = {};
    if (cacheHit = SESSION_STORAGE_MECHANISM[SESSION_STORAGE_KEY]) {
      if (opt.idOnly) {
        return cacheHit;
      }
      data._id = cacheHit;
    }
    try {
      r = (await this.q("post /sessions/get", data));
    } catch (error) {
      e = error;
      throw e;
    }
    SESSION_STORAGE_MECHANISM[SESSION_STORAGE_KEY] = r._id;
    if (opt.idOnly) {
      return r._id;
    }
    r.merged = this._mergeDataChunks(r);
    if (opt.dataOnly) {
      return r.merged;
    }
    // return doc
    return r;
  }

  async addSessionData(key, value) {
    var r, sessionId;
    try {
      sessionId = (await this.getSession({
        idOnly: true
      }));
    } catch (error) {
      e = error;
      throw e;
    }
    log('addSessionData', key, value);
    try {
      r = (await this.q(`post /sessions/${sessionId}/addData`, { key, value }));
    } catch (error) {
      e = error;
      throw e;
    }
    r.merged = this._mergeDataChunks(r);
    log('session data response after add', r);
    return r;
  }

  _mergeDataChunks(doc) {
    var i, item, len, mergedData, ref;
    mergedData = {};
    ref = doc.dataChunks;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      mergedData[item.key] = item.value;
    }
    return mergedData;
  }

  clearSession() {
    try {
      return delete SESSION_STORAGE_MECHANISM[SESSION_STORAGE_KEY];
    } catch (error) { }
  }

  async record(eventObj = {}, opt = {}) {
    var r, ref;
    if (!eventObj.event) {
      throw new Error('event property required');
    }
    if (opt.suppress == null) {
      opt.suppress = true;
    }
    eventObj.userAgent = navigator.userAgent;
    eventObj.url = top.location.href;
    // @todo: append all query string key value pairs
    // ..

    // suppression
    if (opt.suppress && sessionStorage[`EVENT_${eventObj.event}`]) {
      log('Suppressing event', eventObj.event, eventObj);
    }
    try {
      log('Recording event', eventObj.event, eventObj);
      r = (await this.q('POST /events', eventObj));
      return (ref = r != null ? r.ok : void 0) != null ? ref : false;
    } catch (error) {
      e = error;
      throw e;
    }
  }

  async request(method, endpoint, options = {}) {
    var existingParams, existingQuery, headers, jsonResponse, path, response, url;
    [path, existingQuery] = endpoint.split('?');
    url = new URL(`${this.baseUrl}${path}`);
    if (existingQuery) {
      existingParams = new URLSearchParams(existingQuery);
      existingParams.forEach(function (value, key) {
        return url.searchParams.append(key, value);
      });
    }
    if (method.toUpperCase() === 'GET' && options) {
      Object.keys(options).forEach(function (key) {
        return url.searchParams.set(key, options[key]);
      });
    }
    headers = {
      'Content-Type': 'application/json'
    };
    if (this.token) {
      headers['x-session'] = this.token;
    }
    response = (await fetch(url, {
      method: method.toUpperCase(),
      headers: headers,
      body: method === 'GET' ? null : JSON.stringify(options)
    }));
    jsonResponse = (await response.json());
    if (!jsonResponse.ok) {
      throw new Error(jsonResponse.error || 'API request failed');
    }
    return jsonResponse.response;
  }

  get(endpoint, params = {}) {
    return this.request('GET', endpoint, params);
  }

  post(endpoint, body = {}) {
    return this.request('POST', endpoint, body);
  }

  put(endpoint, body = {}) {
    return this.request('PUT', endpoint, body);
  }

  delete(endpoint, body = {}) {
    return this.request('DELETE', endpoint, body);
  }

  call(endpointWithMethod, options = {}) {
    var endpoint, method;
    [method, endpoint] = endpointWithMethod.split(' ');
    return this.request(method.toLowerCase(), endpoint, options);
  }

  query(...x) {
    return this.call(...x);
  }

  q(...x) {
    return this.call(...x);
  }

};

export default ApiClient;